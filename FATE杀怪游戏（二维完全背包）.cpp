#include<iostream>
using namespace std;
//定义两个常量：N:需要积累的经验值的上限，M：能承受的忍耐值的上限，K：怪兽的种类数的上限，S：能杀的最大的怪兽数的上限
#define N 101
#define M 101
#define K 101
#define S 101
//n:需要积累的经验值，m:忍耐值，k:怪兽的种类数，s:能杀的最大的怪兽的数目，a:暂存每种怪兽的经验值，b:存打每种怪兽的消耗的忍耐值，dp[i][j]数组：表示剩下的忍耐值为i，剩下可杀的怪兽数为j时积累的最大的经验值，ans:用来存最后如果能成功升级最后能剩下的最大的忍耐值
int n,m,k,s,a,b,dp[M][S],ans;
int main(){
	//用一个while循环，循环进行的条件就是当还有可读入数据时，就读入对应那组的数据
	//每组数据读入后都必须对ans重新初始化为-1（因为每组数据都假设无法完成升级，那么ans为默认的-1），每次读入一组数据后都必须对dp数组进行初始化，因为最后要判断能不能达到n
	//的经验值，从而成功晋级，而可杀的怪兽数量和忍耐值都是有限的，所以每次都要取杀与不杀的dp最大值，所以要初始化为无穷小，dp[0][0]=0,表示当剩下可忍耐的值为0，可杀怪兽数为0时，能积累的最大的经验值为0
	while(cin>>n>>m>>k>>s){
		ans=-1;
		memset(dp,-0x3f3f3f,sizeof(dp));
		dp[0][0]=0;
		//因为本题是有k种怪兽，每种怪兽的数量是无限的，所以是完全背包问题，又因为本题有两个限制条件：1.不能超出玩家的剩下的忍耐值，2.不能超出玩家最大可杀的怪兽数，所以该题是一个二维问题，（二维完全背包问题）
		//由于对于完全背包问题，可以通过正向遍历内层循环实现状态叠加，从而解决完全背包每种物品可以放无数个的问题，而又由于有两个限制条件，是二维完全背包问题，所以里面要有两个正向遍历的循环
		//外层循环遍历k种怪兽，中层循环正向！！遍历b~m的忍耐值，内层正向遍历1~s的怪兽数，更新状态转移方程：dp[j][k]=max(dp[j][k]不打那只怪兽,dp[j-b][k-1]+a，打那只怪兽)
		for(int i=1;i<=k;i++){
		    cin>>a>>b;
			for(int j=b;j<=m;j++){
				for(int k=1;k<=s;k++){
					dp[j][k]=max(dp[j][k],dp[j-b][k-1]+a);
				}                         
			}
		}
		//由于要求的是剩余的忍耐值，所以不能只是判断dp[m][s]是否达到n的经验值，因为即使此时判断达到了n的经验值，剩下的忍耐度也不一定是最大的，
		//所以要正向遍历整个矩形，如果发现dp的值达到了经验值n，那么求出此时剩下的忍耐值，由于是正向遍历忍耐值，所以此时的剩下的忍耐值一定是最大的，所以直接退出循环，输出最后剩下的最大忍耐值，或者如果发现满足不了晋级条件，就直接输出最开始ans的初始化值-1
		for(int i=0;i<=m;i++){
			for(int j=1;j<=s;j++){
				if(dp[i][j]>=n){
					ans=m-i;      
					goto end;
				}
			}
		}
	end:  cout<<ans<<endl;

} 
return 0;}