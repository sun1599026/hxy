#include<iostream>
using namespace std;
//定义一个变量：n:表示数据的个数
int n;
int main(){
	//读入数据的个数
	//之后设立两个数组：a数组：存n个数据，dp[i]数组：表示以a[i]这个数据为子序列的结尾能得到的最长的不下降子序列的长度
	cin>>n;
	int a[n],dp[n];
	//读入n个数据存入a数组中，之后注意不要忘记进行初始化（因为对于每一个以a[i]数值结尾的不下降子序列的最大值中的最小值一定可以是1
	//因为对于一个以a[i]这个数值结尾的子序列一定包含a[i]这个元素，因此以该元素结尾的最长的不下降子序列的最小值也有1
	//而之所以要对每个以a[i]结束的子序列的子问题都要进行dp[i]=1,是因为如果不对每个dp值赋值为1，那么可能会出错，之后会具体说明
	for(int i=1;i<=n;i++){
		cin>>a[i];
		dp[i]=1;
	}
	//把这个大的问题：对于a1~an的数列的最长不下降子序列，转化为一个个子问题：即分别求以a1~an为结尾的子序列最长不下降子序列的长度
	//分解后的这些子问题之间有很明确的关系，即无后效性，即对于第i个子问题的答案dp[i],第i+1个子问题的dp[i+1]等于：如果逆向遍历ai~a1的
	//过程中如果发现一个比该结尾元素的值小或一样时，那么就可以更新dp[i+1]的值，从之前求得的dp[i+1]和dp[j]+1(即在以a[j]元素结尾的最长的不下降子序列的基础上加1，表示加上a[i+1]
	//这个元素），在这两个值中选一个较大的值赋给dp[i+1]
	for(int i=2;i<=n;i++){
		for(int j=i-1;j>=1;j--){
			if(a[i]>=a[j]){
				dp[i]=max(dp[i],dp[j]+1);
			}
		}
	}	
	//最后再遍历n个子问题，找出以哪个元素为结尾的不下降子序列的长度最长，把最长的值存在maxx中，并输出即可
	int maxx=dp[1];
	for(int j=1;j<=n;j++){
		maxx=max(maxx,dp[j]);
	}
	cout<<maxx;
	return 0;
}