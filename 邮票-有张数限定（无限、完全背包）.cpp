#include<iostream>
using namespace std;
//定义两个常量：K：可贴邮票的总数上限，N：不同分值邮票的种类数上限，MAXX：能得到的连续邮资的上限（200*10000）（可贴邮票数的上限*每张邮票面值上限）
#define K 201
#define N 51
#define MAXX 2000001
//k:可贴邮票的数目，n:不同面值邮票的种类数，ans用来存能得到的最大的连续的邮资
//dp[i]:用来存达到邮资为i时所需要的最少邮票数，a数组：每种邮票的面值
int k,n,ans,a[N],dp[MAXX];
int main(){
	//读入可贴的邮票总数，不同面值邮票的数目以及对应的面值
	cin>>k>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	//由于要求的是最少的邮票数，所以初始化dp数组为无穷大0x3f3f3f3f,dp[0]=0(表示当达到0邮资所需要的最少有票数为0）
	memset(dp,0x3f3f,sizeof(dp));
	dp[0]=0;
	//由于本题中每种邮票可以使用不止一次，所以为完全背包/无限背包问题：
	//习惯上是外循环遍历不同面值的邮票，内循环遍历不同的可能的邮资（因为虽然这题还有一个可贴邮票数量k的限定（一般要进行枚举），但是还有可能达到的总邮资的枚举
	//因为本题最后要求的是最大的连续邮资，所以矩阵的行用来枚举所有可能的邮资，把k这个限定条件放在循环里面进行判断即可)
	//单数由于本题需要在循环里面设置两个出口条件：1.达到邮资为i时最少邮票数超过了上限k，2.无法凑出邮资为i，无法再实现连续了
	//所以将总邮资的枚举放在外循环，内循环进行遍历n种不同面值的邮票，这样当发现邮票数超过k或者无法凑出某邮资时就break出去，输出最大的连续的邮资数
    for(int i=1;i<=MAXX;i++){
     	dp[i]=0x3f3f;
    	for(int j=1;j<=n;j++){
    		//注意当内外循环返回来放时，要进行更新条件的判断，如果剩余所需要达到的邮资j大于等于(千万不要忘记等于！！！！）第i种邮票的面值时就更新dp[j]
    		//状态转移方程为dp[i]=min(dp[i],dp[i-a[j]]+1)
    		if(i>=a[j]){
    			dp[i]=min(dp[i],dp[i-a[j]]+1);
			}
		}
		if(dp[i]>k||dp[i]==0x3f3f){
			break;
		}
	    //如果邮票数量还没超过k，并且可以取到某个值，那么ans++;
     	ans++;
		
	}
	//最后输出连续的最大的邮资
	cout<<ans;
	return 0;
	
}