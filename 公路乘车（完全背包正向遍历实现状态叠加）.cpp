#include<iostream>
using namespace std;
#define N 101
int n,a[11],dp[N];
int main(){
	for(int i=1;i<=10;i++){
		cin>>a[i];
	}
	cin>>n;
	memset(dp,0x3f3f3f,sizeof(dp));
	dp[0]=0;
	//这里通过正向遍历内层循环实现状态叠加达到解决完全背包每个物体可放无数次的问题
	//外层循环遍历10个车站，内层循环遍历正向遍历剩余的可行驶的公里数
	/*之前的01背包的一维数组表示，更新的时候是逆序的，从代码不难看出，对一个值的更新是基于这个值左边的值
   进行更新的，如果是顺序更新，那么在更新时一定会先更新左边的值，从而使得后更新的值有可能基础被更新
   过了，而逆序更新就可以避免这个问题。也可以这么说，因为01背包里面每个物品只能放一次，如果顺序更
    新，那么假设状态1已经放了一个物品了，那么基于状态1的状态2如果需要更新，那么不就变成了放两个物品
    了么，这不就出错了，所以应该需要逆序更新。但是多重背包刚好要判断每个物品要放几次，所以如果正向遍历，假设把左边的某个dp更新过了，记作状态1，在这个状态的基础上再进行进行判断是否还可以继续放该物品，
	如果可以的话就可以基于状态1还可以再放一个该物品*/
	for(int i=1;i<=10;i++){
		for(int j=i;j<=n;j++){
			dp[j]=min(dp[j],dp[j-i]+a[i]);
		}
	}
	cout<<dp[n];
	return 0;
}