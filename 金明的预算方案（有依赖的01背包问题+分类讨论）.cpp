#include<iostream>
using namespace std;
//定义两个常量：N:能花的钱数的上限，M：能买的物品种类数的上限
#define N 3201
#define M 61
//n:能花的钱数，m:物品的种类数，w数组：每个主件的价格，v数组：每个组件的价格*重要性，fw[i][j]数组:第i个主件的第j个附件的价格，fv[i][j]数组：第i个主件的第j个附件的价格*重要性
//dp[j]数组：表示当可用的钱数为j时能得到的最大的价格*重要度之和
//a:暂存每件物品的价格，b:暂存每件物品的重要度，c:暂存每件物品是附件还是主件
int n,m,w[M],v[M],fw[M][M],fv[M][M],dp[N],a,b,c;
int main(){
	//读入可花的钱数，物品的种类数，每件物品的价格，重要度，是否为主件/附件
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a>>b>>c;
		//每读入一个物品都要先判断一下是否为主件，还是为附件，如果是主件，那么就把该主件的价格放在w[i]数组中，把该主件的价格*重要度放在v[i]数组中
		//如果不是主件，那么判断该附件是哪个主件的第几个附件（注意这里要用fw[c][0]++,而不能用普通的计数变量如t++,因为不但要确定是第几个附件，还要确定是第几个主件的附件
		//因此fw[c][0]++,以这种方式就可以确定是第c个主件的第fw[c][0]个附件！！！），之后再把附件的价格放在对应的fw[c][fw[c][0]]中，把附件的价格*重要度放在对应的fv[c][fw[c][0]]中
		if(c==0){
			w[i]=a;
			v[i]=a*b;
		}else{
		     fw[c][0]++;
			 fw[c][fw[c][0]]=a;
			 fv[c][fw[c][0]]=a*b;
		}
	}
    //由于本题时01背包的变型：有依赖的01背包问题，要判断是否为主件附件等不同情况，所以该题在01背包的基础上进行分类讨论：
    //1、只买主件 dp[j]=max(dp[j],dp[j-w[i]]+v[i])
    //2.只买主件和附件1，if(w[i]+fw[i][1]<=j)  dp[j]=max(dp[j],dp[j-w[i]-fw[i][1]]+v[i]+fv[i][1]）
    //3.只买主件和附件2：if(w[i]+fw[i][2]<=j)  dp[j]=max(dp[j],dp[j-w[i]-fw[i][2]]+v[i]+fv[i][2]
    //4.买主件和附件1和附件2  if(w[i]+fw[i][1]+fw[i][2]<=j)  dp[j]=max(dp[j],dp[j-w[i]-fw[i][1]-fw[i][2]]+v[i]+fv[i][1]+fv[i][2])
    
    
    //由于本题是一维优化过的01背包问题，因此对dp数组的第0行进行初始化为0
    for(int j=0;j<=m;j++){
    	dp[j]=0;
	}
	
	//本题是有依赖的01背包问题：最外层循环遍历m种物品，内层循环逆向遍历！！（一维逆行遍历可以防止在使用一维数组进行优化时出现掩盖问题），逆向遍历n~w[i],因为即使有附件比主件的价格更便宜，但是下限不能为该更便宜的附件的价格，因为不能单独买附件，想买附件就必须买对应的主件
	//之后由于存在不同的情况，所以分四种情况进行分类讨论
	for(int i=1;i<=m;i++){
		for(int j=n;j>=w[i];j--){
		   dp[j]=max(dp[j],dp[j-w[i]]+v[i]);//第一种情况：只买主件or主件也不买
		   if(w[i]+fw[i][1]<=j){
		   	dp[j]=max(dp[j],dp[j-w[i]-fw[i][1]]+v[i]+fv[i][1]);//第二种情况：只买主件与附件1or都不买
		   }
		   if(w[i]+fw[i][2]<=j){
		   	dp[j]=max(dp[j],dp[j-w[i]-fw[i][2]]+v[i]+fv[i][2]);//第三种情况：只买主件与附件2or什么都不买
		   }
		   if(w[i]+fw[i][1]+fw[i][2]<=j){
		   	dp[j]=max(dp[j],dp[j-w[i]-fw[i][1]-fw[i][2]]+v[i]+fv[i][1]+fv[i][2]);//第四种情况：买主件、附件1、附件2or什么都不买
		   }
		}
	}
	//最后输出dp[n],表示当可购买的金额为n时能得到的最大的价格*重要性之和
	cout<<dp[n];
	return 0;
	
}
