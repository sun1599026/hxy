#include<iostream>
using namespace std;
//建立两个常量：K:表示邮票种类的上限，N：可贴在信封上的邮票总数的上限，I：表示的是能达到的连续的邮资的最大值（这个最大值直接根据一个现有条件k+n<=40比较难推导出来，所以可以设一个较大的值）
#define K 40
#define N 40
#define I 10000
//n：可贴的邮票的数目，k:邮票的种类，a[k]数组：用来存过程中每种邮票可能的面值，f[i]数组：用来表示达到总邮资i的最少邮票数
//maxx用来存能达到的最大的连续的邮资，b[k]数组：用来存最终k种邮票的面值
int n,k,a[K],f[I],maxx=0,b[K];
void dfs(int m){//m:表示现在是在确定第m种邮票的面值
	//想对前m种邮票进行深搜的前提：必须直到每种邮票的可能的面值的范围，因为只有知道邮票的面值范围，才能枚举每种可能的面值进行深搜（类似于枚举走迷宫类的深搜一样枚举四个可能的方向）
	//由于第m种邮票的可能的面值范围是由第m-1种邮票的面值和前m-1种邮票的面值能得到的最大的连续的邮资maxx决定的
	//由于想要最后的连续的邮资最大，所以每种邮票的面值要在满足邮资连续的前提下尽可能大（如题目的例子中n=3,k=2,b[1]=1,b[2]=4时能达到的最大的连续邮资为6,如果让b[2]为1，那么最大的连续的最大邮资为3，由此可见
	//想要最后得到的连续的邮资最大，那么a[m]要大于等于a[m-1]+1;另外第m种邮票的最大的面值为maxx+1，因为如果第m种邮票的面值大于maxx+1,那么总邮资无法达到第maxx+1,例如
	//n=3,k=2,b[1]=1,b[2]=4时能达到的最大的连续邮资为6,当确定完b[1]为1时，最大的邮资为3，所以第二种邮票的面值最大只能是maxx+1，即4，如果第二种邮票的面值为5，那么最大只能连续到3，无法取到maxx+1=3,所以
	//第m种邮票的面值范围为a[m-1]+1<=a[m]<=maxx+1;那么如何才能求出前m-1种邮票能组成的最大的连续邮资？
	//通01背包（动态规划）来求出最大的maxx,即可确定第m种邮票的面值范围
	
	
	//01背包动态规划：1.先初始化f数组，由于f[i]要求得是达到总邮资为i时最少的邮票数，所以要初始化fz数组中的值大些，1e6即1*10的六次方，由于当要达到的i为0时所需的邮票数为0
	//2，由于每种邮票的数目不限，所以类似于完全背包，内外循环换一下位置没关系，外循环是遍历所有可能的总面值，（由于不知道具体是多少，所以不需要设i的范围）
	//内循环遍历前m种邮票，只有当i>=a[j]时才需要更新f[i]的值，由于要得到最少的邮票数，所以（在选这种面值邮票与不选这种面值邮票达到i所需要的最少邮票）中比较得出最小值
	//由于要设立条件才能跳出外层循环，只有当找到前m种邮票能达到的连续的最大邮资时，才退出
	memset(f,1e6,sizeof(f));
	f[0]=0;
	for(int i=1;;i++){
		for(int j=1;j<=m&&a[j]<=i;j++){
			f[i]=min(f[i],f[i-a[j]]+1);
		}
		//当f[i]的值大于n时，即达到i所需要的邮票数大于规定的最多可贴的邮票数时，就把i--，因为在所有的邮票种类中一定有一种邮票的面值是1，所以把这张面值最小的邮票去掉，就可以在邮票数不超过n的前提下达到最大的连续总邮资
		//由于要最终得到最大的maxx，所以当该轮得到最大的maxx时，要与之前的得到最大的连续邮资进行比较，更新最大的maxx,并把最后确定下来的前m种邮票的面值存在b数组中，就可以break出外循环了
		if(f[i]>n){
			i--;
			if(i>maxx){
				maxx=i;
				for(int k=1;k<=m;k++){
					b[k]=a[k];
				}
			}
			break;
		}
	}
	//在用01背包（动态规划）求得第m+1种邮票的面值范围后，就可以枚举所有的面值，进行深搜，由于最好每种邮票的面值尽可能地大（在满足连续的总邮资前提下），所有逆向遍历
	//枚举第m+1种邮票可能的面值，令a[m+1]=j,再对第m+1种邮票进行深搜，和之前的操作一样，先通过动规求出下一种邮票的面值范围，再进行深搜
	if(m==k) return;
	for(int j=maxx+1;j>=a[m]+1;j--){
		a[m+1]=j;
		dfs(m+1);
	}
}
int main(){
	//读入可贴邮票的总数n,邮票的种类k
	cin>>n>>k;
	//由于在所有种类的邮票中至少要有一种邮票的面值是1，否则如果都是大于1，那么总邮资永远大于1，不可能为1，所以无法实现从1~maxx的连续最大总邮资
	//所以设第一种邮票的面值为1，并以第一种邮票作为起点进行深搜
	a[1]=1;
	dfs(1);
	//最后输出k种邮票的面值，并且输出最大的连续的总邮资
	for(int i=1;i<=k;i++){
		cout<<b[i]<<" ";
	}
	cout<<endl;
	cout<<"MAX= "<<maxx;
	return 0;
	
}