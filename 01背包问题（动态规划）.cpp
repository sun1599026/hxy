#include<iostream>
//由于要用到max函数，引用头文件#include<cmath>
#include<cmath>
using namespace std;
//定义两个常量，m表示的是最大的重量，maxn是物品的件数的上界
#define m 10005
#define maxn 105
//n是指物品的个数，W是购物车的容量，w数组：物品的重量，v数组：物品的价值
//c[i][j]数组：表示前i件物品在容量为j的购物车所能得到的最大价值，x数组是用来记录每个物体是否放入购物车中
int n,W,w[maxn],v[maxn];
int c[maxn][m],x[maxn];
int main(){
	//读入物品的个数，购物车的容量，每件物品的重量和价值
	cin>>n>>W;
	for(int i=1;i<=n;i++){
		cin>>w[i];
	}
	for(int i=1;i<=n;i++){
		cin>>v[i];
	}
	//初始化第一行和第一列为0，表示当物品数为0或容量为0时对应的c一定是等于0
	for(int i=0;i<=W;i++){
		c[0][i]=0;
	}
	for(int j=0;j<=n;j++){
		c[j][0]=0;
	}
	//外循环遍历每件物品，内循环遍历不同剩余容量的购物车，如果物品放不下，那么c[i][j]=c[i-1][j],因为如果最后一个物品不放进去，那么最后的
	//购物车的价值就等价于前i-1个物品放在容量为j的购物车中能达到的最大价值
	//如果能放入，那么比较放入与不放入哪种情况能得到最大的价值，所以c[i][j]=max(c[i-1][j],c[i-1][j-w[i]]+v[i])如果放入的话容量减去w[i]，价值加上放入的物品的价值
	for(int i=1;i<=n;i++){
		for(int j=1;j<=W;j++){
			if(j<w[i]){
				c[i][j]=c[i-1][j];
			}
			else{
				c[i][j]=max(c[i-1][j],c[i-1][j-w[i]]+v[i]);
			}
		}
	}
	//当填充完整个矩阵时最后得到的c[n][W]就是表示前n间物品在W容量的购物车中能达到的最大的价值
	cout<<c[n][W]<<endl;
	//逆向遍历矩阵，遍历n个物品，如果c[i][j]==c[i-1][j],那么表示第i个物品没有放入购物车中，记作x[i]=0;
	//如果c[i][j]>c[i-1][j],表明第i个物品放入了购物车中，记作x[i]=1;不要忘记由于第i个物品放入了，所以容量j-=w[i]
	//同理递推前n个物品，判断是否放入购物车中
	int i=n,j=W;
	for(int i=n;i>=1;i--){
		if(c[i][j]==c[i-1][j]){
			x[i]=0;
		}
		else if(c[i][j]>c[i-1][j]){
			x[i]=1;
			j-=w[i];
		}
	}
	//遍历n个物品，如果该物品标记x[i]=1,表示该编号物品放入了购物车中了，输出物品的编号
	for(int i=1;i<=n;i++){
		if(x[i]==1){
			cout<<i<<" ";
		}
	}
	return 0;
}
