#include<iostream>
//#include<bits/stdc++.h>用万能头文件虽然包含很多头文件，不用一个个去列出头文件，但是也有坏处，因为万能头文件中太多子头文件，寻找时会导致编译时间加长，所以能用#include<iostream>解决，就不用万能头文件了
using namespace std;
//定义常量：N：物品的种类上限，M：奇货的数量上限，C：背包的容量
#define N 10001
#define M 6
#define C 10001
//n:物品的种类数，m：奇货的数量，c:背包的容量，v：每种普通物品的体积，w:每种普通物品的价值，d:每种普通物品的总件数
//a、b、e分别为计算奇货的价值的公式：（第i件的价值Yi与分配的体积Xi之间的关系为：Yi=ai*Xi^2+bi*Xi+ci）中的ai,bi,ci;
//dp[j]数组：表示当背包的容积为j时能装下的最大的价值，vv[i]：是用来存对多重背包进行二进制优化转换为01背包时每件大物品的价值，ww[i]:用来存对多重背包进行二进制优化转为01背包时每件大!!物品的价值
int n,m,c,v,w,d,a,b,e,dp[C],vv[N],ww[N];
//快读函数，为了加快速度，加上inline，返回值为int类型，f：用来标记数的正负，x:用来记录数字是多少
inline int read(){
	int f=1,x=0;
	//先读入一个字符，如果不是字符'0'~'9'，那么表示读入的不是数字，而是字符，如果读入的字符时'-'，表示接下来读入的数字是负数，所以f标记为-1,表示是负数
	//只要读入的不是数字字符，就一直读入
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-'){
			f=-1;
		}
		c=getchar();
	}
	//当读入的是数字字符'0'~'9',表示读入的是数字字符，因此把数字字符转换为数字，转换方法：把已有的x*10,表示前进一位，之后再加上数字（将数字字符-'0'即可得到数字），就能得到一个新数了
	//如果还是数字字符，就接着读入
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	//最后返回f*x，之所以要乘以f,是因为f代表数的正负
	return f*x;
}

int main(){
    //读入普通物品的数量n,奇货的数量m,背包的容量c	
	 n=read();m=read();c=read();
	 //最外层循环遍历n件物品，先读入每件物品的体积、价值、总数
	 //再进行判断是否是完全背包问题:如果发现背包无法装下某种物品的总件数，那么就相当于这种物品是无限个，(因为两种情况都是无法满足装入总件数,如果是多重背包问题，那么每种物品都是可以装下一个确定的有限定的总件数，但是因为现在某种物品无法装下题目所给出的总件数，那么就可以等价于没有限制可以有无限个的完全背包问题，因为两者都不是受自己这类物品的一个数量限制，而是受背包的容量限制）
	 //所以当满足v*d>c时，可以转换为完全背包问题，对于完全背包：外循环遍历n种物品，内循环正向遍历（因为可以实现状态叠加解决完全背包每种物品可装无限个的问题）背包的剩余容量在v~c之间的所有可能，更新dp值，取放与不放第i件物品的最大的价值：	dp[j]=max(dp[j],dp[j-v]+w);
	for(int i=1;i<=n;i++){
		v=read();w=read();d=read();
		if(v*d>c){
			for(int j=v;j<=c;j++){
				dp[j]=max(dp[j],dp[j-v]+w);
			}
		}else{
		//否则如果可以放下该种物品的最大件数，那么就是多重背包问题，对于多重背包问题，进行二进制优化转换为01背包问题
		//二进制优化的方法：让k=1,2,4,8.....，每次k=k*2,第一次将一件物品打包成一个大物品，大物品的体积存在vv[num](最开始num初始化为1，num用来记录大物品的数量）数组里，大物品的价值同理存在ww数组里，num++,
		//因为已经打包了k个物品，所以剩下的物品数为d-=k;之后再同理打包两个、四个、八个.....物品为大物品，并且更新大物品的价值和体积
		//最后发现如果还剩下不是2的倍数的物品，无法像之前的物品那样把2的倍数件物品进行打包，那么就把剩下的物品一起打包成一个大物品，更新大物品的体积和价值
    
			int num=1;
			for(int k=1;k<=d;k*=2){
				vv[num]=k*v;
				ww[num++]=k*w;
				d-=k;
			}
			if(d){
				vv[num]=d*v;
				ww[num++]=d*w;
			}
			//进项二进制优化打包成大物品后，就可以对这些大物品用01背包解决，01背包：外循环遍历num-1件大物品，内循环逆向（因为这样可以进行一维优化，压缩空间复杂度）遍历c~vv[i]的背包容量，更新放与不放的最大价值：	dp[jj]=max(dp[jj],dp[jj-vv[ii]]+ww[ii]);
			for(int ii=1;ii<num;ii++){
				for(int jj=c;jj>=vv[ii];jj--){
					dp[jj]=max(dp[jj],dp[jj-vv[ii]]+ww[ii]);
				}
			}
		}
	}
	//对于m件奇货，直接进行完全背包未进行正向遍历状态叠加优化之前的方法即可，最外层循环遍历m件奇货，中层循环逆向遍历背包的容积j:c~0,最内层循环考虑当背包的容积为j时，考虑放多少体积的物品，k=0~j,
	//最后更新dp值，dp[j]=max(dp[j],dp[j-k]+k*(a*k+b)+e);如果放k体积的物品，那么背包剩余容量为j-k,价值增加a*k^2+b*k+e(题目给出的公式）
	for(int i=1;i<=m;i++){
		a=read();b=read();e=read();
		for(int j=c;j>=0;j--){
			for(int k=0;k<=j;k++){
				dp[j]=max(dp[j],dp[j-k]+k*(a*k+b)+e);
			}
		}
	}
	//最后输出dp[c]，即为能容量为c的背包能装的最大价值
	cout<<dp[c];
	return 0;
}