#include<iostream>
//由于要用到sort函数，所以引用头文件#include<algorithm>
#include<algorithm>
using namespace std;
//定义两个常量：Q：水缸的容量的上限，P：水桶的种类数的上限
#define Q 20001
#define P 101
//q:水缸的容量，p:水桶的种类数，v数组：每种水桶的容积，a数组：最终确定选的那些水桶的体积，maxd:选的水桶的最少的数量，flag用来标记有没有能满足条件的一些水桶
//如果一旦找到了满足能满足装满水缸的水桶，并且由于之前对水桶的容积进行了升序排序，且maxd是从小到大进行枚举的，所以一旦找到能满足装满水缸的水桶，那么此时水桶数一定是最小的，且在多个满足方案中水桶的体积一定是尽量小的
int q,p,v[P],a[P],f[Q],maxd,flag=0;
//bool 类型的check函数，用来判断maxd个桶能否装满水缸，而判断能否装满水缸需要用到完全背包来解决
//因为对于本题有p种水桶，每种水桶的数量又是没有限制的，只有水缸的容量的限制，所以是一个完全背包问题
//对于完全背包问题：外层循环遍历maxd个桶，内层循环正向遍历（因为正向遍历可以实现状态叠加，刚好满足完全背包每种物品可以放无数件的问题）水缸的容量0~q,
//如果f[j]是1（即表示当水缸容量为j的时候用这些maxd水桶是可以装满的），那么如果再满足j+a[i]<=q,(表示如果再用第i个桶装满水，再把这些水倒入水缸中，如果倒入后没有超过水缸的容积q,
//那么如果两个条件都满足的话，那么f[j+a[i]]=1,表示当水缸的容积为j+a[i]时，用maxd个水缸是能够装满的，那么最后再返回f[q]的值,但是当发现之前已经有maxd个桶能满足装满水缸的容积时，那么由于只要输出最佳的方案，因此当输出了一个方案后，由于之前对每个水桶的容积排序过了，因此此时第一个输出的方案就是最佳的方案
bool check(int &q){//由于这个check函数要读入水缸的体积，所以就用&取地址符，就能得到水缸的容积
	if(flag==1){
		return 0;
	}
	memset(f,0,sizeof(f));
	f[0]=1;
	for(int i=1;i<=maxd;i++){
		for(int j=0;j<=q;j++){
			if((f[j]==1)&&(j+a[i]<=q)){
				f[j+a[i]]=1;
			}
		}
	}
	return f[q];
}
void dfs(int ans,int k){
	//dfs函数有两个参数，ans：选到第几个桶了，k:选到第几种桶
	//深搜dfs退出的条件:1.如果选的桶的数量已经达到了规定的maxd+1，表示已经选好了maxd个桶了，那么只需要判断用这maxd个桶能否装满水缸，调用check函数
	//如果通过check函数判断出来这maxd个水桶是可以满足水缸的容积，那么就输出水桶的最少的数量以及每个水桶的容积，并且由于只要输出一种最佳方案，所以输出
	//该最佳方案后，就可以标记flag为1，表示已经找到了一个最佳方案
	if(ans==maxd+1){
		memset(f,-1,sizeof(f));
		if(check(q)){
			cout<<maxd<<" ";
			for(int i=1;i<=maxd;i++){
				cout<<a[i]<<" ";
			}
		    flag=1;
			return;
		}
	}
	//2.如果遍历q种桶，还是没有达到maxd个桶，那么就直接结束
	if(k>q){
		return;
	}
	//否则就假设选了第k个桶，把该桶的体积赋给a[ans],并且假设选了第k个桶，进行深搜，接下来就是深搜dfs(ans+1,k+1)
	//如果深搜失败，那么就不选该桶，接下来就深搜dfs(ans,k+1）
	a[ans]=v[k];
	dfs(ans+1,k+1);
	dfs(ans,k+1);
	return;
}
int main(){
	//读入水缸的容积，水桶的种类数，每个水桶的容积
	cin>>q>>p;
	for(int i=1;i<=p;i++){
		cin>>v[i];
	}
	//根据水桶的容积进行升序排列，由于水桶容积的数组v是从1开始存的，所以sort（v+1,v+p+1)
	sort(v+1,v+p+1);
	//由于本题每种水桶的数量不是只能一个，如果每种水桶的只能选一个，那么直接进行dfs就可以，但是本题每种水桶的数量没有限制，如果直接采用dfs，那么会可能会超限
	//因此可以采用dfs+bfs(即迭代深搜）：即每次dfs都要限制一个深搜的层次k,该次深搜只能在k层进行深搜，之后再不断扩大k的值，直到答案不符合为止，
	//之所以采用迭代深搜，本题1.深度未知，（因为不知道每种桶选的数量未知，且最终选几个桶maxd也是未知）2.本题的状态复杂，（因为每种桶选几个要讨论，要不要选第k种桶也要讨论），因此直接用dfs或bfs不适合，所以用迭代加深搜
	//因此遍历类似于限制层数作用的maxd，maxd表示最终选的最少的桶的数量，可以是1~p,因此枚举1~p，先从dfs(1,1)开始迭代深搜，第一个1表示现在选到第几个桶了，第二个1表示选到第几种桶了（桶的编号）
	for(maxd=1;maxd<=p;maxd++){
		dfs(1,1);
	}
	return 0;
	
}