#include<iostream>
using namespace std;
//定义两个常量：N:可选的课程数目的上限，M：可学习的天数的上限
#define N 101
#define M 101
//n:可选的课程的数目，m:可学习的天数的上限，a[i][j]:表示当学习第i门课花j天学习能获得的分数，dp[k]：表示当前i门课程学习天数的为k的时候，能得到的最高分数
int n,m,a[N][M],dp[M];
int main(){
	//只要还有数据还没读进来时，就读入课程数n,学习的天数m，以及每门不同的课学不同天数能得到的分数
	while(cin>>n>>m){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cin>>a[i][j];
			}
		}
		//对于每组数据在进行dp前都必须要进行初始化，所以一定要把memset放在while里面！！或者由于分组背包问题是类似多个01背包问题，所以像01背包类似的初始化（即把第0行的dp进行初始化为0）
		for(int i=0;i<=n;i++){
			dp[i]=0;
		} 
//		memset(dp,0,sizeof(dp));

//由于本题有n门课，每门课又可以学0~m天，又有总学习天数的限定，且每门课只能确定一个学习天数，所以是分组背包问题
//对于分组背包问题,最外层是遍历n门课程，中层循环！先！！逆向遍历容量m~0,内层循环正向遍历每组中的不同物品，只有当物体的体积小于等于剩余容量时(千万不要写反了！！！），就进行状态更新
//dp[k](因为k是类似01背包中的容量，所以是k),dp[k]=max(dp[k],dp[k-j]+a[i][j]),注意分清楚下标！！
		for(int i=1;i<=n;i++){
			for(int k=m;k>=0;k--){
				for(int j=0;j<=m;j++){
					if(k>=j){
					   dp[k]=max(dp[k],dp[k-j]+a[i][j]);
					}
					
				}
			}
		}
		//最后输出dp[m]即为当总的学习天数为m的时候能得到的最高分数
		cout<<dp[m]<<endl;
	}
	return 0;
}