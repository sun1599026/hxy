#include<iostream>
using namespace std;
//定义两个常量：N：乌龟棋的棋子个数的上限，M：爬行牌的数量的上限
#define N 351
#define M 121
//n:乌龟棋棋盘个数，m:爬行牌的数量，a数组：用来存每个格子的分数，ans[m]数组：用来存爬不同步数的爬行牌的数量，t:爬行牌的可爬行步数
//dp[a][b][c][d]数组：当放了a张爬一步的牌，放了b张爬2步的牌，放了c张爬3步的牌，放了d张爬4步的牌的时候能得到的最高的分数
int n,m,a[N],dp[M][M][M][M],ans[M],t;
int main(){
	//读入乌龟棋棋盘的格子数以及每个格子对应的分数，读入有几张爬行牌，每种爬行牌的数目
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int j=1;j<=m;j++){
		cin>>t;
		ans[t]++;
	}
	//初始化dp数组：dp[0][0][0][0]=a[i](当每种牌放了0张时，即乌龟还在起点，所以能得到的分数就是起点那个格子对应的分数
	dp[0][0][0][0]=a[1];
    //用四个嵌套的for循环即用待定系数法先假定dp[i][j][k][z](走一步的牌放了i张，走两步的牌放了j张，走三步的牌放了k张，走四步的牌放了z张），再返回来像01背包一样从
    //后面推前面的状态，即只要i不等于0，即可以理解为之前假设放的走一步的牌不是0张的前提下，去判断第i张走一步的牌要不要用，如果不用，那么dp还是为dp[i][j][k][z]，因为（剩下可放的牌数）没有改变，但是
    //如果决定放第i张走一步的牌，那么dp[i][j][k][z]=dp[i-1][j][k][z]+a[b],因为放了第i张后剩下的可放一步的牌的数量为i-1张，b=1+1*i+2*j+3*k+4*z,表示假设
	//放了i张爬一步的牌，放了j张爬2步的牌，放了k张爬3步的牌，放了z张爬4步的牌的时候,乌龟能爬到的那个格子的分数加到dp上去，在判断第i张走一步的牌要不要放时先假设其他的j,k,z都是确定好的不变的常量；同理判断走2、3、4的牌要不要放
	for(int i=0;i<=ans[1];i++){
		for(int j=0;j<=ans[2];j++){
			for(int k=0;k<=ans[3];k++){
				for(int z=0;z<=ans[4];z++){
					int b=1+1*i+2*j+3*k+4*z;
					if(i!=0){
						dp[i][j][k][z]=max(dp[i][j][k][z],dp[i-1][j][k][z]+a[b]);
					}
					if(j!=0){
						dp[i][j][k][z]=max(dp[i][j][k][z],dp[i][j-1][k][z]+a[b]);
					}
					if(k!=0){
						dp[i][j][k][z]=max(dp[i][j][k][z],dp[i][j][k-1][z]+a[b]);
					}
					if(z!=0){
						dp[i][j][k][z]=max(dp[i][j][k][z],dp[i][j][k][z-1]+a[b]);
					}
				}
			}
		}
	}
	//最后输出dp[ans[1]][ans[2]][ans[3]][ans[4]],即假设把所有的牌都用了后乌龟能得到的最高分数
	cout<<dp[ans[1]][ans[2]][ans[3]][ans[4]];
	return 0;
}

