#include<iostream>
using namespace std;
//定义两个变量：t:数据的组数，n:每组数据的个数
int t,n;
int main(){
	//读入一共有几组数据
	cin>>t;
	while(t!=0){
		//读入每组数据的数据个数，以及每个数据具体的值
		//定义两个数组：a数组：用来存每个数据的值，dp[i]：表示以第a[i]元素结尾的连续子串的最大和
		cin>>n;
		int a[n],dp[n];
		for(int i=0;i<n;i++){
			cin>>a[i];
		}
		//由于dp[0]：表示以a[0]结尾的连续子串的最大的和，因为只有一个数据，所以dp[0]=a[0]
		dp[0]=a[0];
		//把一个大问题：求a1~an这组数中能构成的连续子串的最大和，分解成一个个小问题：含有a[i]元素的连续子串的最大的和，
		//但是会发现前i个子问题与第i+1个子问题没有关联，即为有后效性，因此再具体化子问题：求以第a[i]元素结尾的连续子串的最大的和，
		//此时可以发现，如果dp[i-1]<=0,即表示以a[i-1]结尾的连续子串的最大和为负数或0，那么求第i+1个问题时可以去掉第i个子问题的答案，下一个子问题的答案就是单个元素a[i+1],即dp[i+1]=a[i+1]
		//如果第i个子问题的答案是大于0，那么下一个子问题i+1的答案就是dp[i+1]=dp[i]+a[i+1],因此综上所述，可得状态转移方程：dp[i]=max(a[i],dp[i-1]+a[i]),即求两种情况的最大值即可
		for(int i=0;i<n;i++){
			dp[i]=max(a[i],dp[i-1]+a[i]);
		}
		//最后先假设最大值maxx=dp[0],最后遍历所有的子问题（分别以a1~an结尾的连续子串的和的最大值），找出以哪个数结尾的连续子串得到的最大值最大，赋值给maxx,最后输出maxx即可
		int maxx=dp[0];
		for(int j=1;j<n;j++){
			maxx=max(maxx,dp[j]);
		}
		cout<<maxx<<endl;
		//求完一组数据后，就t--,直到t=0（t组数据都得到了连续子串的最大值）
		t--;
	}
	return 0;
}