#include<iostream>
using namespace std;
//定义两个常量：M：可分配的机器装置的数量的上限，N：需要分配机器的公司的数量上限
#define M 16
#define N 11
//定义m:需要分配的机器数量，n:需要分配的公司数量，a[i][j]数组：表示当分配机器数为i时不同公司j的盈利,dp[i][j]数组：当分配前i台机器给前j家公司能得到的最大盈利
int m,n,a[M][N],dp[M][N];
int main(){
	//读入需要分配的机器的数量，公司的数量，以及分配不同数量机器给不同的公司能获得的盈利
	cin>>m>>n;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	//由于该题是一个分组背包问题，而分组背包问题又类似01背包问题，因此对dp数组进行类似01背包的初始化，让第0行第0列初始化为0，表示当需要分配的机器数为0货值分配的公司为0时能获得的最大盈利为0
	//初始化dp[1][1]=a[1][1],因为dp[1][1]作为填充矩阵的初始点，只有将dp[1][1]初始化正确才能保证之后基于该起始点推得的点的dp值是正确的，因为dp[1][1]表示的是当需要分配的机器数为 1，分配给第一家公司能得到的最大的盈利就是a[1][1]
	for(int i=0;i<=n;i++){
		dp[i][0]=0;
	}
	for(int j=0;j<=m;j++){
		dp[0][j]=0;
	}
	dp[1][1]=a[1][1];
	//接下来的三重循环是对于分组背包的通用的解法，最外层的循环，表示遍历不同的n家公司，相当于遍历n个不同的组，中层循环遍历每个组中可能分配到的装备数，相当于遍历同一组中的不同物品，
	//最内层循环遍历该物品可能放的件数，这里相当于当该物品为最多可分配到j个装备，那么具体要分到几个，这个就需要用到最内层循环，
	//分组背包问题，最外层循环相当遍历有几组01背包问题，中层循环相当于遍历01背包中的不同的物品，内层循环相当于遍历可放该物品的数量范围，由于在01背包问题中
	//为了实现只用一维数组，但又要防止掩盖，因此需要逆向遍历范围，每次遍历一个物品具体需要几件时需要初始化最大盈利max=0,再遍历最内层循环判断具体该物体需要几件时能实现最大的盈利，不断比较得到最大值，把该最大值赋给dp[j][i],就是表示给前i家
	//提供j台机器装备能得到的最大的盈利值，在确定某个物品具体放几件时，假设放了k台设备，那么状态转移方程为dp[j-k][i-1]+a[k][i],因为已将放了k台，那么剩下的可放的机器数量为j-k,还需要分配的公司数i-1,加上分配k台机器给第i家公司能得到的盈利a[k][i]
	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++){
			int max=0;
			for(int k=j;k>=0;k--){
			    if(dp[j-k][i-1]+a[k][i]>max){
			    	max=dp[j-k][i-1]+a[k][i];
				}
			}
			dp[j][i]=max;
		}
	}
	//最后输出dp[m][n]表示分配m台设备给n家公司能得到的最大的盈利
	cout<<dp[m][n];
	return 0;
}