#include<iostream>
using namespace std;
//定义三个常量：N：叔叔能给多多买的碟的数量上限，M:商店能卖给叔叔的碟的数量上限，L：爷爷允许多多看DVD的时间上限
#define N 101
#define M 101
#define L 1001
//n:叔叔能买给多多的碟的数量，m:商店能卖给叔叔的碟的数量，l:爷爷允许多多看DVD的时长，a数组：每种不同的碟的观看所需的时间，s数组：每种碟看了后能得到分数，dp[i][j]:当从商店买i张碟，可观看的时间的时间为j,能得到的最大分数
int n,m,l,a[N],s[N],dp[M][L];
int main(){
	//读入叔叔能买给多多的碟的数量n，商店能卖给叔叔的碟的数量m,爷爷允许多多看碟时间为l
	//以及每张碟观看所需要的时间，以及看完后能得到的对应的分数
	cin>>n>>m>>l;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>s[i];
	}
	//由于最后要求的是能得到的最大分数，因此要初始化数组dp为无穷小-0x3f3f3f,并且初始化dp[0][0]=0,表示当能卖的碟数为0，能观看的时间为0，时能得到的最大的分数为0
	memset(dp,-0x3f3f3f,sizeof(dp));
	dp[0][0]=0;
	//由于本题有两个限制条件：买的的碟数不能超过m,观看的总时长不能超过l，因此本题是二维的01背包问题，
	//又由于要用一维数组降低空间复杂度，所以内层的限制条件的循环要逆向遍历！！
	//最外层循环遍历叔叔愿意给多多买的dvd的数量，中层循环逆向遍历商店能卖的碟的数量m~0,内层循环逆向遍历能观看的时间l~a[i]
	//那么更新状态转移方程：dp[j][k]=max(dp[j][k],dp[j-1][k-a[i]])即取买第i张碟和不买第i张碟能得到的dp的最大值
	for(int i=1;i<=n;i++){
		for(int j=m;j>=0;j--){
			for(int k=l;k>=a[i];k--){
				dp[j][k]=max(dp[j][k],dp[j-1][k-a[i]]+s[i]);
			}
		}
	}
	//最后输出dp[m][l]表示当商店可卖的碟的数量为m，爷爷允许多多看DVD的时间为l时能得到的最高分数
	cout<<dp[m][l];
	return 0;
}