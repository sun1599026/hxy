#include<iostream>
using namespace std;
//定义两个常量：M：能花的最多的大洋钱数的上限，R：人品的值的最大的上限，N：妹妹的数量的上限
#define M 101
#define R 101
#define N 101
//n：妹妹的数量，m:大洋的数量，r:人品值，a数组：邀请每位妹妹吃晚饭所需要花的大洋，b数组：邀请每位做自己gf所需要花费的人品值，c数组：搞定每位妹妹所需要的时间，dp[i][j]：
//当说剩下可用的大洋数为i,剩下可用的人品值为j时在能邀请到最多妹妹的前提下所需花费的最少时间
int n,m,r,a[N],b[N],c[N],dp[M][R];
int main(){
	//读入有n位妹妹，以及每位妹妹的信息：消耗的大洋，消耗的人品，消耗的时间
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i]>>c[i];
	}
	cin>>m>>r;
	//由于要求的是邀请尽可能多的妹妹所需的最少的时间，所以刚开始要初始化数组dp的每个值为无穷大0x3f3f3f,再初始化dp[0][0]=0,表示当剩下可用的大洋为0，人品值为0时
	//是邀请不到妹妹的，又由于题目中讲了当主人公发现邀请不到妹妹的时候他会选择去录题，所以邀请妹妹的时间为0
	memset(dp,0x3f3f3f,sizeof(dp));
	dp[0][0]=0;
	//由于本题是一个二维的01背包问题，因为有两个限制条件：不能超过m个大洋，不能超过r的人品值，所以是一个二维的01背包问题
	//所以最外层循环遍历n个妹妹，中层循环逆向遍历m~a[i](因为在01背包中想用一维数组降低空间复杂度时，又为了防止掩盖，因此内层循环要逆向遍历，同理，要最内层循环
	//要逆向遍历r~b[i]，当满足条件时要进行状态转移方程：dp[j][k]=min(dp[j][k],dp[j-a[i]][k-b[i]]+c[i])即进行判断要不要选择第i个妹妹
	for(int i=1;i<=n;i++){
		for(int j=m;j>=a[i];j--){
			for(int k=r;k>=b[i];k--){
				dp[j][k]=min(dp[j][k],dp[j-a[i]][k-b[i]]+c[i]);
			}
		}
	}
	//最后要输出dp[m][r]即为当可用的大洋数为m，人品为r时能在交到最多gf的前提下，所需要花的最少时间
	cout<<dp[m][r];
	return 0;
}