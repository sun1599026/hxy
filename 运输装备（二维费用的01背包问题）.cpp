#include<iostream>
using namespace std;
//定义三个常量：V：货车的可装载体积的上限，G：货车的可承重的上限，N：装备的件数的上限
#define V 1001
#define G 1001
#define N 1001
//v:可装载的最大体积，g:可承重的上限，n:装备的数量，a数组：存装备的火力值，b数组：装备的体积，c数组：装备的重量，dp[i][j]数组:当装载i体积，j重量的装备的最大火力
int v,g,n,a[N],b[N],c[N],dp[V][V];
int main(){
	//读入货车的可装载的最大体积，最大承重，装备的数量，每件装备的火力值，体积，重量
	cin>>v>>g;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i]>>c[i];
	}
	//由于要求的是最大的火力值，所以刚开始要初始化dp数组中的元素为无穷小，dp[0][0]=0,表明当装载的装备的体积为0，重量为0（即没有装物品时）能达到的最大火力值为0
	memset(dp,-0x3f3f,sizeof(dp));
	dp[0][0]=0;
	//由于该题有两个限制变量，最大装载体积v，最大承重重量g,所以要模拟01背包，但是有两层逆向遍历
	//最外层循环遍历每件装备，内层的两个循环，分别逆向遍历（因为用逆行遍历可以使dp数组降维，如01背包中通过内层循环逆向遍历实现dp从二维降至一维，本题也通过逆向遍历实现dp数组从四维降至二维，降低了空间复杂度
	//内两层循环分别逆向遍历v~b[i],和 g~c[i]，更新dp[j][k]=max(dp[j][k]不放第i个装备，dp[j-b[i]][k-c[i]]+a[i],放第i个装备）
	for(int i=1;i<=n;i++){
		for(int j=v;j>=b[i];j--){
			for(int k=g;k>=c[i];k--){
		       dp[j][k]=max(dp[j][k],dp[j-b[i]][k-c[i]]+a[i]);
			}
		}
	}
	//最后输出dp[v][g],即为在可装载最大体积为v,可承重的最大重量为g时能得到的最大的火力值
	cout<<dp[v][g];
	return 0;
}